export type Difficulty = 'junior' | 'mid' | 'senior';

export interface Question {
  id: number;
  question: string;
  options: string[];
  correct: number;
  explanation: string;
  difficulty: Difficulty;
}

export const questions: Question[] = [
  // JUNIOR DEVELOPER
  {
    id: 1,
    question: "What will `typeof []` return?",
    options: ["array", "object", "null", "undefined"],
    correct: 1,
    difficulty: 'junior',
    explanation: "Arrays are objects in JavaScript. The typeof operator returns 'object' for arrays because they are instances of Object. To check for arrays specifically, use Array.isArray().",
  },
  {
    id: 2,
    question: "What is the output of `console.log(0.1 + 0.2 === 0.3)`?",
    options: ["true", "false", "undefined", "null"],
    correct: 1,
    difficulty: 'junior',
    explanation: "JavaScript uses floating-point arithmetic which has precision issues. 0.1 + 0.2 results in 0.30000000000000004, not exactly 0.3. This is a known IEEE 754 limitation.",
  },
  {
    id: 3,
    question: "Which of the following is NOT a falsy value in JavaScript?",
    options: ["0", "''", "[]", "null"],
    correct: 2,
    difficulty: 'junior',
    explanation: "Empty arrays [] are truthy in JavaScript. Falsy values are: false, 0, -0, 0n, '', null, undefined, and NaN. Everything else, including empty arrays and objects, is truthy.",
  },
  {
    id: 4,
    question: "What does `const` prevent from being reassigned?",
    options: [
      "The entire object structure",
      "The variable reference",
      "Properties of an object",
      "Nothing, it's the same as let",
    ],
    correct: 1,
    difficulty: 'junior',
    explanation: "const prevents reassignment of the variable reference itself, but properties of const objects can still be modified. For example, const obj = {a: 1}; obj.a = 2 is valid.",
  },
  {
    id: 5,
    question: "What will this code log? `const x = [1,2,3]; console.log(x.slice(0,2))`",
    options: ["[1, 2]", "[1]", "[1, 2, 3]", "undefined"],
    correct: 0,
    difficulty: 'junior',
    explanation: "slice(0, 2) returns elements from index 0 up to (but not including) index 2, so it returns [1, 2]. Remember: slice is non-destructive and doesn't modify the original array.",
  },
  {
    id: 6,
    question: "Which array method removes the last element?",
    options: ["shift()", "unshift()", "pop()", "slice()"],
    correct: 2,
    difficulty: 'junior',
    explanation: "pop() removes and returns the last element. shift() removes the first, unshift() adds to the beginning, and slice() creates a new array without modifying the original.",
  },
  {
    id: 7,
    question: "What will `[1,2,3].map(x => x * 2)` return?",
    options: [
      "[2, 4, 6]",
      "6",
      "undefined",
      "null",
    ],
    correct: 0,
    difficulty: 'junior',
    explanation: "map() transforms each element using the provided function and returns a new array. Here, each element is multiplied by 2, resulting in [2, 4, 6].",
  },
  {
    id: 8,
    question: "How do you declare a variable that cannot be changed?",
    options: ["let", "const", "var", "static"],
    correct: 1,
    difficulty: 'junior',
    explanation: "const declares a variable that cannot be reassigned. However, if it holds an object, the properties can still be modified. let is block-scoped but can be reassigned.",
  },
  {
    id: 9,
    question: "What is the difference between null and undefined?",
    options: [
      "There is no difference",
      "null is intentional, undefined is unintentional",
      "undefined is an assignment, null is not set",
      "null is an object, undefined is a number",
    ],
    correct: 1,
    difficulty: 'junior',
    explanation: "null is an intentional assignment representing 'no value', while undefined represents the absence of a value (uninitialized variables, functions without return statements).",
  },
  {
    id: 10,
    question: "Which method adds elements to the end of an array?",
    options: ["unshift()", "push()", "concat()", "splice()"],
    correct: 1,
    difficulty: 'junior',
    explanation: "push() adds one or more elements to the end of an array and modifies the original. unshift() adds to the beginning, while concat() creates a new array without modification.",
  },

  // MID-LEVEL DEVELOPER
  {
    id: 11,
    question: "What is a closure?",
    options: [
      "A function that closes with a closing brace",
      "A function that has access to its outer function's scope",
      "A function that closes a connection",
      "A statement that closes a loop",
    ],
    correct: 1,
    difficulty: 'mid',
    explanation: "A closure is a function that retains access to its lexical scope even after the outer function has returned. This is fundamental to JavaScript and enables data privacy and factory patterns.",
  },
  {
    id: 12,
    question: "What is the correct way to check if a property exists in an object?",
    options: [
      "obj[prop] !== undefined",
      "obj.hasOwnProperty(prop)",
      "'prop' in obj",
      "All of the above",
    ],
    correct: 3,
    difficulty: 'mid',
    explanation: "All three methods work but have nuances. hasOwnProperty() checks own properties only, 'in' checks the prototype chain, and !== undefined fails if the property exists but is undefined.",
  },
  {
    id: 13,
    question: "What is the output of `console.log(typeof typeof 1)`?",
    options: ["number", "string", "undefined", "object"],
    correct: 1,
    difficulty: 'mid',
    explanation: "typeof 1 returns 'number' (a string), then typeof 'number' returns 'string'. The outer typeof always returns a string, making this a good test of understanding typeof's return type.",
  },
  {
    id: 14,
    question: "What will `Promise.resolve(5)` return?",
    options: [
      "5",
      "Promise { <pending> }",
      "Promise { 5 }",
      "undefined",
    ],
    correct: 2,
    difficulty: 'mid',
    explanation: "Promise.resolve(5) returns a Promise object that resolves with the value 5. It's immediately settled but still wrapped in a Promise, useful for converting values to Promises.",
  },
  {
    id: 15,
    question: "How do you properly clone an object in JavaScript?",
    options: [
      "obj = originalObj",
      "const obj = { ...originalObj }",
      "const obj = Object.assign({}, originalObj)",
      "Both B and C for shallow clones",
    ],
    correct: 3,
    difficulty: 'mid',
    explanation: "Both spread operator and Object.assign() create shallow clones. For deep clones with nested objects, use structuredClone() or libraries like lodash. Direct assignment just creates a reference.",
  },
  {
    id: 16,
    question: "What is the result of `5 + '5'` in JavaScript?",
    options: ["10", "'55'", "'10'", "NaN"],
    correct: 1,
    difficulty: 'mid',
    explanation: "JavaScript performs type coercion. The + operator concatenates when one operand is a string, so 5 becomes '5' and the result is '55'. This demonstrates implicit type conversion.",
  },
  {
    id: 17,
    question: "What does the `async` keyword do?",
    options: [
      "Makes function run asynchronously",
      "Makes function return a Promise",
      "Allows use of await inside the function",
      "All of the above",
    ],
    correct: 3,
    difficulty: 'mid',
    explanation: "async marks a function as asynchronous, always returning a Promise. It enables the use of await inside the function. Even if the function returns a value directly, it's wrapped in a Promise.",
  },
  {
    id: 18,
    question: "What will `[1, 2, 3].filter(x => x > 2)` return?",
    options: [
      "[1, 2, 3]",
      "[3]",
      "[]",
      "undefined",
    ],
    correct: 1,
    difficulty: 'mid',
    explanation: "filter() creates a new array with elements that pass the test function. Only 3 is greater than 2, so it returns [3]. The original array is unchanged.",
  },
  {
    id: 19,
    question: "What will `Object.keys({a: 1, b: 2})` return?",
    options: [
      "[1, 2]",
      "['a', 'b']",
      "{a: 1, b: 2}",
      "undefined",
    ],
    correct: 1,
    difficulty: 'mid',
    explanation: "Object.keys() returns an array of the object's own enumerable property names (keys). It doesn't return the values or the object itself, making it useful for iterating over object keys.",
  },
  {
    id: 20,
    question: "What is a higher-order function?",
    options: [
      "A function that takes functions as arguments or returns functions",
      "A function with more than 5 lines",
      "A function inside another function",
      "A recursive function",
    ],
    correct: 0,
    difficulty: 'mid',
    explanation: "Higher-order functions take functions as arguments or return functions. Examples include map(), filter(), reduce(), and function decorators. They're essential for functional programming.",
  },

  // SENIOR DEVELOPER
  {
    id: 21,
    question: "What is event delegation and when should you use it?",
    options: [
      "Adding listeners to each element individually",
      "Attaching a single listener to a parent to handle events from children",
      "Using preventDefault on all events",
      "Creating custom events for DOM manipulation",
    ],
    correct: 1,
    difficulty: 'senior',
    explanation: "Event delegation uses event bubbling to handle events on child elements with a single listener on a parent. It's more efficient for dynamic content and reduces memory usage.",
  },
  {
    id: 22,
    question: "How do you implement the Module pattern?",
    options: [
      "Using export default",
      "Creating an IIFE to encapsulate private and public variables",
      "Using only const declarations",
      "Importing all functions at once",
    ],
    correct: 1,
    difficulty: 'senior',
    explanation: "The Module pattern uses an IIFE (Immediately Invoked Function Expression) to create a closure with private variables and return an object with public methods. This predates ES6 modules.",
  },
  {
    id: 23,
    question: "What is the difference between call, apply, and bind?",
    options: [
      "They are identical functions",
      "call takes arguments as a list, apply takes an array, bind returns a function",
      "Only call and apply exist in modern JavaScript",
      "bind is only for arrow functions",
    ],
    correct: 1,
    difficulty: 'senior',
    explanation: "call() invokes immediately with args as list, apply() invokes immediately with args as array, and bind() returns a new function with fixed this value. All three control the this context.",
  },
  {
    id: 24,
    question: "What are the key differences between var, let, and const?",
    options: [
      "They are all identical",
      "var is function-scoped, let and const are block-scoped, const can't be reassigned",
      "Only const should be used in modern code",
      "var is deprecated and shouldn't be used",
    ],
    correct: 1,
    difficulty: 'senior',
    explanation: "var has function scope, let/const have block scope. const prevents reassignment but allows property mutation. Temporal Dead Zone affects let/const. Use const by default, let when needed, avoid var.",
  },
  {
    id: 25,
    question: "How does prototypal inheritance work in JavaScript?",
    options: [
      "Objects inherit from classes like in Java",
      "Objects delegate to their prototype object, which can delegate to its prototype",
      "Inheritance only happens through the new keyword",
      "Prototypes are just for storing methods",
    ],
    correct: 1,
    difficulty: 'senior',
    explanation: "JavaScript uses prototype delegation. Objects look up properties in their prototype chain. This enables code reuse without classical inheritance. Understanding [[Prototype]] is crucial.",
  },
  {
    id: 26,
    question: "What is the purpose of WeakMap and when should you use it?",
    options: [
      "It's slower than regular Map",
      "It stores weakly-referenced keys, allowing garbage collection and preventing memory leaks",
      "It's only for storing weak passwords",
      "It's deprecated in favor of Map",
    ],
    correct: 1,
    difficulty: 'senior',
    explanation: "WeakMap holds weak references to keys, so keys can be garbage collected. Keys must be objects. Perfect for private data in libraries and DOM-to-object associations.",
  },
  {
    id: 27,
    question: "How do you implement memoization?",
    options: [
      "Storing function results in a cache to avoid recalculation",
      "Using the memo React hook only",
      "Caching variables in localStorage",
      "Memoization is not supported in JavaScript",
    ],
    correct: 0,
    difficulty: 'senior',
    explanation: "Memoization caches function results based on inputs. Implement using closures and objects: const memoized = (() => { const cache = {}; return (x) => cache[x] || (cache[x] = expensiveFunc(x)); })();",
  },
  {
    id: 28,
    question: "What is the difference between shallow and deep equality?",
    options: [
      "They are the same thing",
      "Shallow checks only top level, deep recursively compares nested structures",
      "Only shallow equality matters in JavaScript",
      "Deep equality is impossible in JavaScript",
    ],
    correct: 1,
    difficulty: 'senior',
    explanation: "Shallow equality compares object references and primitive values directly. Deep equality recursively compares nested structures. Important for state management and testing.",
  },
  {
    id: 29,
    question: "How does the event loop work in JavaScript?",
    options: [
      "All code executes synchronously in order",
      "Call stack processes sync code, callback queue handles async, microtask queue runs before macrotask",
      "setTimeout always runs before promises",
      "The event loop doesn't exist in modern JavaScript",
    ],
    correct: 1,
    difficulty: 'senior',
    explanation: "The event loop manages execution: call stack (sync), microtask queue (promises, process.nextTick), and macrotask queue (setTimeout, I/O). Microtasks run before the next macrotask.",
  },
  {
    id: 30,
    question: "What are Proxy and Reflect used for?",
    options: [
      "Only for network requests",
      "Intercept and customize operations on objects, with Reflect providing methods for default behavior",
      "Deprecated in ES2020",
      "Proxy is only for functions",
    ],
    correct: 1,
    difficulty: 'senior',
    explanation: "Proxy intercepts operations (get, set, delete, etc.) on objects for validation, logging, or custom behavior. Reflect provides methods to perform default operations, useful with Proxy traps.",
  },
];
